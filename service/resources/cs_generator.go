package resources

import (
	"fmt"
	"go-deploy/models/sys/vm"
	"go-deploy/pkg/conf"
	"go-deploy/pkg/subsystems/cs/models"
	"go-deploy/service"
	"go-deploy/service/vm_service/constants"
	"go-deploy/utils/subsystemutils"
	"golang.org/x/exp/slices"
	"time"
)

type CsGenerator struct {
	*PublicGeneratorType
}

func (cr *CsGenerator) SOs() []models.ServiceOfferingPublic {
	var res []models.ServiceOfferingPublic

	if cr.v.vm != nil {
		if so := &cr.v.vm.Subsystems.CS.ServiceOffering; service.Created(so) {

			if cr.v.updateParams != nil {

				if cr.v.updateParams.RAM == nil {
					so.RAM = *cr.v.updateParams.RAM
				}

				if cr.v.updateParams.CpuCores != nil {
					so.CpuCores = *cr.v.updateParams.CpuCores
				}
			}

			res = append(res, *so)

			return res
		} else {
			res = append(res, models.ServiceOfferingPublic{
				Name:        subsystemutils.GetPrefixedName(cr.v.vm.Name),
				Description: fmt.Sprintf("Auto-generated by deploy for vm %s", cr.v.vm.Name),
				CpuCores:    cr.v.vm.Specs.CpuCores,
				RAM:         cr.v.vm.Specs.RAM,
				DiskSize:    cr.v.vm.Specs.DiskSize,
			})

			return res
		}
	}

	return nil
}

func (cr *CsGenerator) VMs() []models.VmPublic {
	var res []models.VmPublic

	if cr.v.vm != nil {
		if csVM := &cr.v.vm.Subsystems.CS.VM; service.Created(csVM) {
			csVM.ServiceOfferingID = cr.v.vm.Subsystems.CS.ServiceOffering.ID
			res = append(res, *csVM)
			return res
		} else {
			res = append(res, models.VmPublic{
				Name:              cr.v.vm.Name,
				ServiceOfferingID: cr.v.vm.Subsystems.CS.ServiceOffering.ID,
				TemplateID:        constants.TemplateID,
				Tags:              createTags(cr.v.vm.Name, cr.v.vm.Name),
			})
			return res
		}
	}

	return nil
}

func (cr *CsGenerator) PFRs() []models.PortForwardingRulePublic {
	var res []models.PortForwardingRulePublic

	if cr.v.vm != nil {
		ports := cr.v.vm.Ports

		for mapName, pfr := range cr.v.vm.Subsystems.CS.PortForwardingRuleMap {
			idx := slices.IndexFunc(ports, func(p vm.Port) bool {
				keep := p.Name == mapName &&
					p.Protocol == pfr.Protocol &&
					p.Port == pfr.PrivatePort

				return keep
			})

			if idx != -1 {
				res = append(res, pfr)
			}
		}

		for _, port := range ports {
			if _, ok := cr.v.vm.Subsystems.CS.PortForwardingRuleMap[port.Name]; !ok {
				res = append(res, models.PortForwardingRulePublic{
					Name:        port.Name,
					VmID:        cr.v.vm.Subsystems.CS.VM.ID,
					NetworkID:   cr.v.vmZone.NetworkID,
					IpAddressID: cr.v.vmZone.IpAddressID,
					PublicPort:  0, // this is set externally
					PrivatePort: port.Port,
					Protocol:    port.Protocol,
					Tags:        createTags(port.Name, cr.v.vm.Name),
				})
			}
		}

		return res
	}

	return nil
}

func createTags(name string, deployName string) []models.Tag {
	return []models.Tag{
		{Key: "name", Value: name},
		{Key: "managedBy", Value: conf.Env.Manager},
		{Key: "deployName", Value: deployName},
		{Key: "createdAt", Value: time.Now().Format(time.RFC3339)},
	}
}
